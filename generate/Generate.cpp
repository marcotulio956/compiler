#include <cstdio>
#include <cctype>
#include <cassert>
#include <iostream>

#include "Generate.h"

SymbolTable symboltable;

Generate::Generate(SymbolTable* st) : symbolTable(st){
}
 
 Generate::~Generate(){}

CodGenerate(){
    super(); // isso aq chama o construtor desse TypeCheck
}

void codeGenRoot(ListNode node, std::string fileName)
{
// nao entendi essa linah debaixo aqui
// throws SemanticException, GenCodeException

    TypeCheckRoot(node);
    printf(" Semantic error found");

    int i;
    i = fileName.lastIndexOf(File.separator);
    SourceFile = fileName.substring(i+1);

    if(i<0){
        SourcePath = "";
    }
    else{
        SourcePath = fileName.substring(0,i);
    }
    SourceAbs= fileName;
    CodeGenClassDeclListNode(node);
}

void codeGenClassDeclNode(ClassDeclNode node){
//throws GenCodeException

symbolTable  tempHold = currentTable; // salva tabela corrente (atual)
boolean tempStart = hasStart; // salva a variavel hasStart
EntryClass c = null;
EntryClass nc = null;
std::string FileName = null, sName;
FileOutputStream os;
PrintWriter fpOld = fp; // salva o arq sendo gerado

if(node = null) return;

// acha classe na tabela
nc=EntryClass currentTable.classFindUp(node, name, image);
ns = nc.parent; // pega a superclasse

//pega o nome da superclasse
if(ns==null){
    sName = "java/lang/Object";
}
else{
    sName= ns.completeName();
}
FileName = SourceAbs + "." + nc.completeName() + Jasextension;
try{
    //cria arq p gerar cod na classe
    os = new FileOutputStream(FileName);
}
catch(FileNotFoundExceprion e){
    throw new GenCodeException("Cannot create output file: " + FileName);
}
fp = new PrintWriter(os);
printf("Generating" + FileName);

// escreve o cabeÃ§ado do arquivo .source . class e .super
putCode(";------------------------");
putCode("; Code generated by NOME DO NOSSO COMPILADOR");
putCode("; Version 1.0 - 2022");
putCode(";------------------------");
putCode(".source"+ SourceFile);
putCode(".class public" + nc.completeName());
putCode(".super" + sName);

currentTable = nc.nested; // tabela corrente = tabela da classe
hasStart = false;
codeGenClassBodyNode(node, body);
if(hasStart){
    createMain();
}
fp.close(); // fecha arq
fp = fpOld; // recupera arq anterior
currentTable = tempHold; //recupera tablea corrente
hasStart= tempStart; // recupera flag
}

void createMain(){
    EntryClass  v = (EntryClass) currentTable.levelUp;
    putCode();
    putCode(";Entry point for the JVM");
    putCode(".method static public main([Ljava/lang/String;)V");
    putCode(".limit locals 1");
    putCode(".limit stack 1");
    putCode("invokeStatitc langXrt/Runtime/initialize()I");
    putCode("ifne     end");
    putCode("pop");
    putCode("end");
    putCode("invokeStatic langXrt/Runtime/finilizy()V");
    putCode("return");
    putCode(".end method");
}

void CodeGenClassBodyNode(ClassBodyNode node)
//throws GenCodeException
{
    EntryMethod l;
    if(node == null) return;
    CodeGendClassDeclListNode(node.clist);
    CodeGenVarDeclListNode(node.vlist);
    l = currentTable.methodFindInClass("constructor", null);
    if(l.fake){
        GeraConstructorDefault();
    }
    CodeGenConstructDeclListNode(node.ctlist);
    CodeGenMethodDeclListNode(node.mlist);

}



