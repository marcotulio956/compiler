#include <cstdio>
#include <cctype>
#include <cassert>
#include <iostream>

#include "Generate.h"

SymbolTable symboltable;

Generate::Generate(SymbolTable* st) : symbolTable(st){
}
 
 Generate::~Generate(){}

CodGenerate(){
    super(); // isso aq chama o construtor desse TypeCheck
}

void codeGenRoot(ListNode node, std::string fileName)
{
// nao entendi essa linah debaixo aqui
// throws SemanticException, GenCodeException

    TypeCheckRoot(node);
    printf(" Semantic error found");

    int i;
    i = fileName.lastIndexOf(File.separator);
    SourceFile = fileName.substring(i+1);

    if(i<0){
        SourcePath = "";
    }
    else{
        SourcePath = fileName.substring(0,i);
    }
    SourceAbs= fileName;
    CodeGenClassDeclListNode(node);
}

void codeGenClassDeclNode(ClassDeclNode node){
//throws GenCodeException

symbolTable  tempHold = currentTable; // salva tabela corrente (atual)
boolean tempStart = hasStart; // salva a variavel hasStart
EntryClass c = null;
EntryClass nc = null;
std::string FileName = null, sName;
FileOutputStream os;
PrintWriter fpOld = fp; // salva o arq sendo gerado

if(node = null) return;

// acha classe na tabela
nc=EntryClass currentTable.classFindUp(node, name, image);
ns = nc.parent; // pega a superclasse

//pega o nome da superclasse
if(ns==null){
    sName = "java/lang/Object";
}
else{
    sName= ns.completeName();
}
FileName = SourceAbs + "." + nc.completeName() + Jasextension;
try{
    //cria arq p gerar cod na classe
    os = new FileOutputStream(FileName);
}
catch(FileNotFoundExceprion e){
    throw new GenCodeException("Cannot create output file: " + FileName);
}
fp = new PrintWriter(os);
printf("Generating" + FileName);

// escreve o cabeÃ§ado do arquivo .source . class e .super
putCode(";------------------------");
putCode("; Code generated by NOME DO NOSSO COMPILADOR");
putCode("; Version 1.0 - 2022");
putCode(";------------------------");
putCode(".source"+ SourceFile);
putCode(".class public" + nc.completeName());
putCode(".super" + sName);

currentTable = nc.nested; // tabela corrente = tabela da classe
hasStart = false;
codeGenClassBodyNode(node, body);
if(hasStart){
    createMain();
}
fp.close(); // fecha arq
fp = fpOld; // recupera arq anterior
currentTable = tempHold; //recupera tablea corrente
hasStart= tempStart; // recupera flag

}

